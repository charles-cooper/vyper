from typing import Dict

from vyper.codegen.ir_basicblock import IRValueBase
from vyper.semantics.types.function import ContractFunctionT
from vyper.utils import OrderedSet


def build_gas_estimates(func_ts: Dict[str, ContractFunctionT]) -> dict:
    # note: `.gas_estimate` is added to ContractFunctionT._ir_info
    # in vyper/semantics/types/function.py
    ret = {}
    for k, v in func_ts.items():
        ret[k] = v._ir_info.gas_estimate
    return ret


def expand_source_map(compressed_map: str) -> list:
    """
    Expand a compressed source map string.

    Arguments
    ---------
    compressed_map : str
        `sourceMap` as generated by the compiler, i.e. "1:1:0;;;;3::2;;;4;"

    Returns
    -------
    List
        Expanded source map as `[[start, length, jump, source id], .. ]`
    """
    source_map: list = [_expand_row(i) if i else None for i in compressed_map.split(";")[:-1]]

    for i, value in enumerate(source_map[1:], 1):
        if value is None:
            source_map[i] = source_map[i - 1][:3] + [None]
            continue
        for x in range(3):
            if source_map[i][x] is None:
                source_map[i][x] = source_map[i - 1][x]

    return source_map


def _expand_row(row):
    result = [None] * 4
    for i, value in enumerate(row.split(":")):
        if value:
            result[i] = value if i == 3 else int(value)
    return result


# REVIEW: move this to vyper/ir/ or vyper/venom/
# rename to StackModel
class StackMap:
    NOT_IN_STACK = object()
    stack_map: list[IRValueBase]  # REVIEW: rename to stack
    # REVIEW: dead variable
    dependant_liveness: OrderedSet[IRValueBase]

    def __init__(self):
        self.stack_map = []
        self.dependant_liveness = OrderedSet()

    def copy(self):
        new = StackMap()
        new.stack_map = self.stack_map.copy()
        return new

    def get_height(self) -> int:
        """
        Returns the height of the stack map.
        """
        return len(self.stack_map)

    def push(self, op: IRValueBase) -> None:
        """
        Pushes an operand onto the stack map.
        """
        assert isinstance(op, IRValueBase), f"push takes IRValueBase, got '{op}'"
        self.stack_map.append(op)

    def pop(self, num: int = 1) -> None:
        del self.stack_map[len(self.stack_map) - num :]

    def get_depth_in(self, op: IRValueBase | list[IRValueBase]) -> int:
        """
        Returns the depth of the first matching operand in the stack map.
        If the operand is not in the stack map, returns NOT_IN_STACK.
        """
        assert (
            isinstance(op, str)
            or isinstance(op, int)
            or isinstance(op, IRValueBase)
            or isinstance(op, list)
        ), f"get_depth_in takes IRValueBase or list, got '{op}'"

        for i, stack_op in enumerate(self.stack_map[::-1]):
            if isinstance(stack_op, IRValueBase):
                # REVIEW: handling literals this way seems a bit cursed,
                # why not use IRLiteral, so it is always IRValueBase?
                if isinstance(op, str) and stack_op.value == op:
                    return -i
                if isinstance(op, int) and stack_op.value == op:
                    return -i
                if isinstance(op, IRValueBase) and stack_op.value == op.value:
                    return -i
                # REVIEW: this branch seems cursed
                elif isinstance(op, list) and stack_op in op:
                    return -i

        return StackMap.NOT_IN_STACK

    def peek(self, depth: int) -> IRValueBase:
        """
        Returns the top of the stack map.
        """
        return self.stack_map[depth - 1]

    def poke(self, depth: int, op: IRValueBase) -> None:
        """
        Pokes an operand at the given depth in the stack map.
        """
        assert depth <= 0, "Bad depth"
        assert isinstance(op, IRValueBase), f"poke takes IRValueBase, got '{op}'"
        self.stack_map[depth - 1] = op

    def dup(self, assembly: list[str], depth: int) -> None:
        """
        Duplicates the operand at the given depth in the stack map.
        """
        assert depth <= 0, "Cannot dup positive depth"
        assembly.append(f"DUP{-(depth-1)}")
        self.stack_map.append(self.peek(depth))

    def swap(self, assembly: list[str], depth: int) -> None:
        """
        Swaps the operand at the given depth in the stack map with the top of the stack.
        """
        # convenience, avoids branching in caller
        if depth == 0:
            return

        assert depth < 0, "Cannot swap positive depth"
        assembly.append(f"SWAP{-depth}")
        self.stack_map[depth - 1], self.stack_map[-1] = (
            self.stack_map[-1],
            self.stack_map[depth - 1],
        )
